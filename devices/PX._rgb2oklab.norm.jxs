<jittershader name="rgb2oklab">
    <description>Shader for converting sRGB to OKLab color space</description>
    <param name="tex0" type="int" default="0" />
    <language name="glsl" version="1.0">
        <bind param="tex0" program="fp" />
        <program name="vp" type="vertex">
            <![CDATA[

varying vec2 texcoord0;

void main() {
    gl_Position = ftransform();
    texcoord0 = vec2(gl_TextureMatrix[0] * gl_MultiTexCoord0);
}
]]>
        </program>
        <program name="fp" type="fragment">
            <![CDATA[

varying vec2 texcoord0;
uniform sampler2DRect tex0;

vec3 srgb_to_linear(vec3 c) {
    return mix(c / 12.92, pow((c + 0.055) / 1.055, vec3(2.4)), step(0.04045, c));
}

float cbrtf(float v) {
	return pow(v, 1./3.);
}

vec3 rgb2oklab(vec3 c) {
    float l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b;
	float m = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b;
	float s = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b;

	float l_ = cbrtf(l);
	float m_ = cbrtf(m);
	float s_ = cbrtf(s);
	
	return vec3(
		0.2104542553*l_ + 0.7936177850*m_ - 0.0040720468*s_,
		1.9779984951*l_ - 2.4285922050*m_ + 0.4505937099*s_,
		0.0259040371*l_ + 0.7827717662*m_ - 0.8086757660*s_
	);
}

vec3 normalizeRange(vec3 value) {
    vec3 minVal = vec3(0., -1.838,  -0.450);
    vec3 maxVal = vec3(1.004, 1.253, 0.264);
    return (value - minVal) / (maxVal - minVal);
}

vec4 rgb2oklab(vec4 rgba) {
    vec4 oklaba;
    oklaba.rgb = normalizeRange(rgb2oklab(srgb_to_linear(rgba.rgb)));
    oklaba.a = rgba.a;

    return oklaba;
}

void main() {
    vec4 rgba = texture2DRect(tex0, texcoord0);
    vec4 oklaba = rgb2oklab(rgba);
    gl_FragColor = oklaba;
}
]]>
        </program>
    </language>
</jittershader>
