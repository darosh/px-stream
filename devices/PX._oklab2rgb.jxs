<jittershader name="oklab_to_linear_srgb">
    <description>Convert OKLab (stored as L, a+0.5, b+0.5) back to linear sRGB</description>
    <param name="tex0" type="int" default="0" />
    <language name="glsl" version="1.0">
        <bind param="tex0" program="fp" />
        <program name="vp" type="vertex">
            <![CDATA[
varying vec2 texcoord0;

void main() {
    gl_Position = ftransform();
    texcoord0 = vec2(gl_TextureMatrix[0] * gl_MultiTexCoord0);
}
]]>
        </program>

        <program name="fp" type="fragment">
            <![CDATA[
varying vec2 texcoord0;
uniform sampler2DRect tex0;

vec3 oklab_to_linear_srgb(vec3 lab) {
    // Expand encoded values
    float L = lab.r;
    float a = lab.g;
    float b = lab.b;

    // OKLab -> LMS (cube-rooted)
    mat3 oklab_to_lms_cbrt = mat3(
        1.0,  0.3963377774,  0.2158037573,
        1.0, -0.1055613458, -0.0638541728,
        1.0, -0.0894841775, -1.2914855480
    );
    vec3 lms_cbrt = oklab_to_lms_cbrt * vec3(L, a, b);

    // Cube to get LMS
    vec3 lms = lms_cbrt * lms_cbrt * lms_cbrt;

    // LMS -> linear RGB
    mat3 lms_to_rgb = mat3(
         4.0767416621, -3.3077115913,  0.2309699292,
        -1.2684380046,  2.6097574011, -0.3413193965,
        -0.0041960863, -0.7034186147,  1.7076147010
    );
    return lms_to_rgb * lms;
}

// Overload for vec4 (decode from stored format: a,b offset by -0.5)
vec4 oklab_to_linear_srgb(vec4 encoded) {
    vec3 lab = vec3(encoded.r, encoded.g, encoded.b);
    lab.r = lab.r * 8. - 4.;
    lab.gb = lab.gb * 4. - 2.;
    vec3 rgb = oklab_to_linear_srgb(lab);
    //rgb = clamp(rgb, 0.0, 1.0);
    return vec4(rgb, encoded.a);
}

void main() {
    vec4 encoded = texture2DRect(tex0, texcoord0);
    gl_FragColor = oklab_to_linear_srgb(encoded);
}
]]>
        </program>
    </language>
</jittershader>